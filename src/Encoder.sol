// File automatically generated by protoc-gen-sol v0.2.0
// and then fixed by @wilsoncusack :)
// SPDX-License-Identifier: CC0
pragma solidity >=0.6.0 <8.0.0;
pragma experimental ABIEncoderV2;

import "@lazyledger/protobuf3-solidity-lib/contracts/ProtobufLib.sol";

enum MessageType {
    MESSAGE_TYPE_NONE,
    MESSAGE_TYPE_CAST_ADD,
    MESSAGE_TYPE_CAST_REMOVE,
    MESSAGE_TYPE_REACTION_ADD,
    MESSAGE_TYPE_REACTION_REMOVE,
    MESSAGE_TYPE_LINK_ADD,
    MESSAGE_TYPE_LINK_REMOVE,
    MESSAGE_TYPE_VERIFICATION_ADD_ETH_ADDRESS,
    MESSAGE_TYPE_VERIFICATION_REMOVE,
    MESSAGE_TYPE_SIGNER_ADD,
    MESSAGE_TYPE_SIGNER_REMOVE,
    MESSAGE_TYPE_USER_DATA_ADD,
    MESSAGE_TYPE_USERNAME_PROOF,
    MESSAGE_TYPE_FRAME_ACTION
}

enum FarcasterNetwork {
    FARCASTER_NETWORK_NONE,
    FARCASTER_NETWORK_MAINNET,
    FARCASTER_NETWORK_TESTNET,
    FARCASTER_NETWORK_DEVNET
}

struct MessageData {
    MessageType type_;
    uint64 fid;
    uint32 timestamp;
    FarcasterNetwork network;
    FrameActionBody frame_action_body;
}

library MessageDataCodec {
    // Holds encoded version of message
    struct MessageData__Encoded {
        bytes type___Key;
        bytes type_;
        bytes fid__Key;
        bytes fid;
        bytes timestamp__Key;
        bytes timestamp;
        bytes network__Key;
        bytes network;
        FrameActionBodyCodec.FrameActionBody__Encoded__Nested frame_action_body;
        bytes frame_action_body__Encoded;
    }

    // Holds encoded version of nested message
    struct MessageData__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(MessageData memory instance) internal pure returns (bytes memory) {
        MessageData__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding type_ if default value
        if (uint64(instance.type_) != 0) {
            // Encode key for type_
            encodedInstance.type___Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.Varint));

            // Encode type_
            encodedInstance.type_ = ProtobufLib.encode_int32(int32(uint32(instance.type_)));
        }

        // Omit encoding fid if default value
        if (uint64(instance.fid) != 0) {
            // Encode key for fid
            encodedInstance.fid__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.Varint));
            // Encode fid
            encodedInstance.fid = ProtobufLib.encode_uint64(instance.fid);
        }

        // Omit encoding timestamp if default value
        if (uint64(instance.timestamp) != 0) {
            // Encode key for timestamp
            encodedInstance.timestamp__Key = ProtobufLib.encode_key(3, uint64(ProtobufLib.WireType.Varint));
            // Encode timestamp
            encodedInstance.timestamp = ProtobufLib.encode_uint32(instance.timestamp);
        }

        // Omit encoding network if default value
        if (uint64(instance.network) != 0) {
            // Encode key for network
            encodedInstance.network__Key = ProtobufLib.encode_key(4, uint64(ProtobufLib.WireType.Varint));
            // Encode network
            encodedInstance.network = ProtobufLib.encode_int32(int32(uint32(instance.network)));
        }

        // Encode frame_action_body
        encodedInstance.frame_action_body = FrameActionBodyCodec.encodeNested(16, instance.frame_action_body);

        encodedInstance.frame_action_body__Encoded = abi.encodePacked(
            encodedInstance.frame_action_body.key,
            encodedInstance.frame_action_body.length,
            encodedInstance.frame_action_body.nestedInstance
        );

        bytes memory finalEncoded;
        len = 0;
        len += uint64(encodedInstance.type___Key.length);
        len += uint64(encodedInstance.type_.length);
        len += uint64(encodedInstance.fid__Key.length);
        len += uint64(encodedInstance.fid.length);
        len += uint64(encodedInstance.timestamp__Key.length);
        len += uint64(encodedInstance.timestamp.length);
        len += uint64(encodedInstance.network__Key.length);
        len += uint64(encodedInstance.network.length);
        // len += uint64(encodedInstance.frame_action_body.key.length);
        len += uint64(encodedInstance.frame_action_body__Encoded.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.type___Key.length) {
            finalEncoded[index++] = encodedInstance.type___Key[j++];
        }
        j = 0;
        while (j < encodedInstance.type_.length) {
            finalEncoded[index++] = encodedInstance.type_[j++];
        }
        j = 0;
        while (j < encodedInstance.fid__Key.length) {
            finalEncoded[index++] = encodedInstance.fid__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.fid.length) {
            finalEncoded[index++] = encodedInstance.fid[j++];
        }
        j = 0;
        while (j < encodedInstance.timestamp__Key.length) {
            finalEncoded[index++] = encodedInstance.timestamp__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.timestamp.length) {
            finalEncoded[index++] = encodedInstance.timestamp[j++];
        }
        j = 0;
        while (j < encodedInstance.network__Key.length) {
            finalEncoded[index++] = encodedInstance.network__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.network.length) {
            finalEncoded[index++] = encodedInstance.network[j++];
        }
        j = 0;
        while (j < encodedInstance.frame_action_body__Encoded.length) {
            finalEncoded[index++] = encodedInstance.frame_action_body__Encoded[j++];
        }

        return finalEncoded;
    }

    // Encode a nested MessageData, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, MessageData memory instance)
        internal
        pure
        returns (MessageData__Encoded__Nested memory)
    {
        MessageData__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }
}

struct CastId {
    uint64 fid;
    bytes hash;
}

library CastIdCodec {
    // Holds encoded version of message
    struct CastId__Encoded {
        bytes fid__Key;
        bytes fid;
        bytes hash__Key;
        bytes hash__Length;
        bytes hash;
    }

    // Holds encoded version of nested message
    struct CastId__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(CastId memory instance) internal pure returns (bytes memory) {
        CastId__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding fid if default value
        if (uint64(instance.fid) != 0) {
            // Encode key for fid
            encodedInstance.fid__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.Varint));
            // Encode fid
            encodedInstance.fid = ProtobufLib.encode_uint64(instance.fid);
        }

        // Omit encoding hash if default value
        if (bytes(instance.hash).length > 0) {
            // Encode key for hash
            encodedInstance.hash__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode hash
            encodedInstance.hash__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.hash).length));
            encodedInstance.hash = bytes(instance.hash);
        }

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.fid__Key.length);
        len += uint64(encodedInstance.fid.length);
        len += uint64(encodedInstance.hash__Key.length);
        len += uint64(encodedInstance.hash__Length.length);
        len += uint64(encodedInstance.hash.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.fid__Key.length) {
            finalEncoded[index++] = encodedInstance.fid__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.fid.length) {
            finalEncoded[index++] = encodedInstance.fid[j++];
        }
        j = 0;
        while (j < encodedInstance.hash__Key.length) {
            finalEncoded[index++] = encodedInstance.hash__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.hash__Length.length) {
            finalEncoded[index++] = encodedInstance.hash__Length[j++];
        }
        j = 0;
        while (j < encodedInstance.hash.length) {
            finalEncoded[index++] = encodedInstance.hash[j++];
        }

        return finalEncoded;
    }

    // Encode a nested CastId, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, CastId memory instance)
        internal
        pure
        returns (CastId__Encoded__Nested memory)
    {
        CastId__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }
}

struct FrameActionBody {
    bytes url;
    uint32 button_index;
    CastId cast_id;
}

library FrameActionBodyCodec {
    // Holds encoded version of message
    struct FrameActionBody__Encoded {
        bytes url__Key;
        bytes url__Length;
        bytes url;
        bytes button_index__Key;
        bytes button_index;
        CastIdCodec.CastId__Encoded__Nested cast_id;
        bytes cast_id__Encoded;
    }

    // Holds encoded version of nested message
    struct FrameActionBody__Encoded__Nested {
        bytes key;
        bytes length;
        bytes nestedInstance;
    }

    function encode(FrameActionBody memory instance) internal pure returns (bytes memory) {
        FrameActionBody__Encoded memory encodedInstance;
        uint64 len;
        uint64 index;

        // Omit encoding url if default value
        if (bytes(instance.url).length > 0) {
            // Encode key for url
            encodedInstance.url__Key = ProtobufLib.encode_key(1, uint64(ProtobufLib.WireType.LengthDelimited));
            // Encode url
            encodedInstance.url__Length = ProtobufLib.encode_uint64(uint64(bytes(instance.url).length));
            encodedInstance.url = bytes(instance.url);
        }

        // Omit encoding button_index if default value
        if (uint64(instance.button_index) != 0) {
            // Encode key for button_index
            encodedInstance.button_index__Key = ProtobufLib.encode_key(2, uint64(ProtobufLib.WireType.Varint));
            // Encode button_index
            encodedInstance.button_index = ProtobufLib.encode_uint32(instance.button_index);
        }

        // Encode cast_id
        encodedInstance.cast_id = CastIdCodec.encodeNested(3, instance.cast_id);

        encodedInstance.cast_id__Encoded = abi.encodePacked(
            encodedInstance.cast_id.key, encodedInstance.cast_id.length, encodedInstance.cast_id.nestedInstance
        );

        bytes memory finalEncoded;
        index = 0;
        len = 0;
        len += uint64(encodedInstance.url__Key.length);
        len += uint64(encodedInstance.url__Length.length);
        len += uint64(encodedInstance.url.length);
        len += uint64(encodedInstance.button_index__Key.length);
        len += uint64(encodedInstance.button_index.length);
        // len += uint64(encodedInstance.cast_id.key.length);
        len += uint64(encodedInstance.cast_id__Encoded.length);
        finalEncoded = new bytes(len);

        uint64 j;
        j = 0;
        while (j < encodedInstance.url__Key.length) {
            finalEncoded[index++] = encodedInstance.url__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.url__Length.length) {
            finalEncoded[index++] = encodedInstance.url__Length[j++];
        }

        j = 0;
        while (j < encodedInstance.url.length) {
            finalEncoded[index++] = encodedInstance.url[j++];
        }

        j = 0;
        while (j < encodedInstance.button_index__Key.length) {
            finalEncoded[index++] = encodedInstance.button_index__Key[j++];
        }
        j = 0;
        while (j < encodedInstance.button_index.length) {
            finalEncoded[index++] = encodedInstance.button_index[j++];
        }
        j = 0;
        while (j < encodedInstance.cast_id__Encoded.length) {
            finalEncoded[index++] = encodedInstance.cast_id__Encoded[j++];
        }

        return finalEncoded;
    }

    // Encode a nested FrameActionBody, wrapped in key and length if non-default
    function encodeNested(uint64 field_number, FrameActionBody memory instance)
        internal
        pure
        returns (FrameActionBody__Encoded__Nested memory)
    {
        FrameActionBody__Encoded__Nested memory wrapped;

        wrapped.nestedInstance = encode(instance);

        uint64 len = uint64(wrapped.nestedInstance.length);
        if (len > 0) {
            wrapped.key = ProtobufLib.encode_key(field_number, 2);
            wrapped.length = ProtobufLib.encode_uint64(len);
        }

        return wrapped;
    }
}
